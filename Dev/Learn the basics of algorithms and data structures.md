---
tags:
  - computerScience
  - en
---
# Learn the basics of algorithms and data structures

![https://res.cloudinary.com/practicaldev/image/fetch/s--RgsP06Qp--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/frucxzj55gj8fjozpjav.PNG](https://res.cloudinary.com/practicaldev/image/fetch/s--RgsP06Qp--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/frucxzj55gj8fjozpjav.PNG)

For anyone who hasn't gone trough a proper CS program the programming theory is a challenging topic. Learning how to code, learning syntax and just using the chosen programming language is already a challenge. Soon (when one aims to get to a professional level) student finds out about more abstract topics which are not a matter of a particular language but they are shared amongs many. Such topics are programming paradigms like OOP or functional programming, algorithms, etc. Algorithms are particularly important, since we all are using them no matter the language or framework we prefer. As a self-taught developer I have felt that I'm missing out on this fundamental knowledge which is not commonly taught on the internet. So I have researched for a book that would help me understand it at least a bit. Unfortunately most of the theoretical literature consists of thick and hard-to-read books. Well except the **grokking algorithms** by **A. Y. Bhargava**.

# Contents of the book

It's structured into rather independent chapters covering always one coherent topic (it's always a specific algorithm, except for the beginning of the book ). Depending on the knowledge you already have you can read it in two ways, chapter by chapter: that is obviously best for those with zero knowledge, or you can cherry pick chapters: and this is probably best approach for the second reading or for those who know about some of the algorithms already. But overall it's a book for beginners so experienced programmers will probably find it useless.

## Big O Notation

One of the first concepts introduced is a so-called Big O Notation. This is, simply put, a measurement of time efficiency of a given algorithm. Even with the contemporary computers if one chooses a wrong algorithm for the job, they can wait for years for it to finish.

> "big o" ---> O(n)

## Data structures

Throughout the book you'll learn not only about algorithms but also about data structures. For us, JavaScript, developers this is quite foreign topic. There is an array in JS but what it really is and how it actually works? Well that's a topic for another article. However in this book you will learn what is: **array**, **queue**, **linked list**, **stack** and **hash table**.

## The algorithms

The author has picked only a handful of algorithms but also the most important or rather most useful ones or even better put those which you might most probably see in the code you work with at work.

Starting with **binary search**, **quicksort** going trough **Breadth-first search**, **Dijkstra's algorithm** and finishing with **K-nearest neighbours**.

I've found the book most useful in the early chapters because it helped me to put together scarcely found information on the internet and the latter topics I sometimes had a hard time to grasp and I will definitely get back to them once I will need it.

One of the side-topics is **Recursion chapter** which I found very important because this is an idea that you build many algorithms on top of and you will most probably use it in a real-life project at some point.

# Do the exercises (when you feel like doing them)

The author stresses out multiple times that readers should open an editor and try running or writing the code themselves. The code examples in the text are written in Python but JS being my language I have tried to write some of the algorithms myself.

I do agree that having the code in your hands helps but as I don't usually like to read sitting by the desk I've tried out only a few of the samples and whenever I felt that I don't need to see it on the screen I just skipped and understood it anyway (hopefully).

# Conclusion

I haven't really talked about the drawings in the book. This wasn't really a selling point for me because I don't have this type of memory and I'm quite used to learn from textbooks but I can see that it may be an important thing for a lots of readers - so simply put the illustrations are well made, comprehensive and funny.

I really recommend to get a copy of this book and keep it close by to be able to reference it when needed. It helped me a lot to feel comfortable about another theoretical aspect of the programming.

...

This is my first ever article published here and also the first text I have written on a technical topic, so I hope you've found it helpful and enjoyed reading it.