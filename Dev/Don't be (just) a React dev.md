- nÃ¡pad od Prima
    
- generalist > specialist
    
- specialist just for a while
    
- necessary evil of marketing yourself on LI
    
- go deeper, learn more about the foundations
    
- don't overdo it, you can't know it all, set some boundaries
# Don't be (just) a React dev

What makes a career of a software engineer successful? That's up to individuals to decide but it's quite important for this piece of opinion to have it defined. So the way I see it: One can feel good about their SWE career if they progress, gradually learn new things, and the stuff they build is having an impact.

On the other hand stagnation, repetitive tasks and throw-away projects that happen just to prevent a budget go to waste (what an irony) are my definition of a boring and unsuccessful career.

In reality it's probably a scale but what I'm trying to say is that if you care about your profession as a SWE you should strive to tilt the scale towards the "successful" end.

## Am I even a software engineer?
You may object: "Well I'm a software developer." or "a frontend developer" or a "Go dev" or whatever. And that's exactly the problem which I'm addressing. You've mistaken either your current role, the niche you're interested in or a key-word cluster that recruiters are searching for on job portals with your profession.

You are in fact a SWE before anything else. Or at least you should be! There is the never-ending struggle to differentiate an engineer and a developer, so let me explain what kind of person I'm talking about: SWE builds software, cares about the discipline and wants to be as good as they can be. Maybe you don't call it a SWE but I do, so get over it. And I hope that the definition is broad enough that you feel you fit in.

## I'm a specialist
And that's great... for the time being. Defining a niche for yourself can give you an advantage on the market especially as a freelancer but you should be a generalist with one or more specialisations rather then a one-trick pony.

I know it's tough and there is so much to know about computers, networking, software etc. but it's crucial to understand to a certain degree most of it because then you are equipped and ready to tackle any challenge. Even knowing that there are things out there besides a framework or language or paradigm that you currently use is useful. Wide range of perspectives on the same problem will result in a more suitable, more effective, faster or just better solution than just one.

Resort to the limiting specialist label only for marketing reasons when you search for a job or clients but think of yourself as an engineer.

## Delve deeper
Wherever there is an API there is code underneath it and then there is language and runtime and compiler and so on. You should try and understand how the thing you're using works not only how to use it. In the end you'll be surprised that it's not that difficult.

This knowledge will make you more confident when working with the tool and will give you an edge over others who don't care. Then when an edge case comes up and you will be the one who can solve it because you know more then how to use the API, you'll reap the harvest of your hard work.

So many people get into this profession (myself included) without a CS degree. They learn Python or JavaScript and a framework and the manage to get their first job. Well that's just the beginning. You can't get stuck at that point thinking you've made it. You don't know shit about this thing. You need to go deeper or else you'll be just another React dev. And what happens when React inevitably goes out of fashion?

### The Abstractions
Unfortunately even though the entry may not have been too hard you have chosen the more difficult way to become a SWE. Going through formal education path is not perfect but it's easier because you go from bottom to the top of the abstraction stack. You learn first about semiconductors, computers, low-level languages, networking, operating systems and you climb slowly up to the highest abstraction.

When starting from the high abstraction point it's hard to see downwards. From this point of view the abstraction is actually working as an obfuscation layer.